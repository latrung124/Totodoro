/**
 * user_service.proto
 * No description provided (generated by Openapi Generator
 * https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: version not set
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIUserServiceApi.h"
#include "OAIServerConfiguration.h"
#include <QJsonArray>
#include <QJsonDocument>

namespace OpenAPI {

OAIUserServiceApi::OAIUserServiceApi(const int timeOut)
    : _timeOut(timeOut)
    , _manager(nullptr)
    , _isResponseCompressionEnabled(false)
    , _isRequestCompressionEnabled(false)
{
	initializeServerConfigs();
}

OAIUserServiceApi::~OAIUserServiceApi()
{
}

void OAIUserServiceApi::initializeServerConfigs()
{
	// Default server
	QList<OAIServerConfiguration> defaultConf = QList<OAIServerConfiguration>();
	// varying endpoint server
	defaultConf.append(OAIServerConfiguration(
	    QUrl("/"), "No description provided", QMap<QString, OAIServerVariable>()));
	_serverConfigs.insert("userServiceCreateUser", defaultConf);
	_serverIndices.insert("userServiceCreateUser", 0);
	_serverConfigs.insert("userServiceGetSettings", defaultConf);
	_serverIndices.insert("userServiceGetSettings", 0);
	_serverConfigs.insert("userServiceGetUser", defaultConf);
	_serverIndices.insert("userServiceGetUser", 0);
	_serverConfigs.insert("userServiceUpdateSettings", defaultConf);
	_serverIndices.insert("userServiceUpdateSettings", 0);
	_serverConfigs.insert("userServiceUpdateUser", defaultConf);
	_serverIndices.insert("userServiceUpdateUser", 0);
}

/**
 * returns 0 on success and -1, -2 or -3 on failure.
 * -1 when the variable does not exist and -2 if the value is not defined in the enum and -3 if the
 * operation or server index is not found
 */
int OAIUserServiceApi::setDefaultServerValue(
    int serverIndex, const QString &operation, const QString &variable, const QString &value)
{
	auto it = _serverConfigs.find(operation);
	if (it != _serverConfigs.end() && serverIndex < it.value().size()) {
		return _serverConfigs[operation][serverIndex].setDefaultValue(variable, value);
	}
	return -3;
}

void OAIUserServiceApi::setServerIndex(const QString &operation, int serverIndex)
{
	if (_serverIndices.contains(operation)
	    && serverIndex < _serverConfigs.find(operation).value().size()) {
		_serverIndices[operation] = serverIndex;
	}
}

void OAIUserServiceApi::setApiKey(const QString &apiKeyName, const QString &apiKey)
{
	_apiKeys.insert(apiKeyName, apiKey);
}

void OAIUserServiceApi::setBearerToken(const QString &token)
{
	_bearerToken = token;
}

void OAIUserServiceApi::setUsername(const QString &username)
{
	_username = username;
}

void OAIUserServiceApi::setPassword(const QString &password)
{
	_password = password;
}

void OAIUserServiceApi::setTimeOut(const int timeOut)
{
	_timeOut = timeOut;
}

void OAIUserServiceApi::setWorkingDirectory(const QString &path)
{
	_workingDirectory = path;
}

void OAIUserServiceApi::setNetworkAccessManager(QNetworkAccessManager *manager)
{
	_manager = manager;
}

/**
 * Appends a new ServerConfiguration to the config map for a specific operation.
 * @param operation The id to the target operation.
 * @param url A string that contains the URL of the server
 * @param description A String that describes the server
 * @param variables A map between a variable name and its value. The value is used for substitution
 * in the server's URL template. returns the index of the new server config on success and -1 if the
 * operation is not found
 */
int OAIUserServiceApi::addServerConfiguration(
    const QString &operation,
    const QUrl &url,
    const QString &description,
    const QMap<QString, OAIServerVariable> &variables)
{
	if (_serverConfigs.contains(operation)) {
		_serverConfigs[operation].append(OAIServerConfiguration(url, description, variables));
		return _serverConfigs[operation].size() - 1;
	} else {
		return -1;
	}
}

/**
 * Appends a new ServerConfiguration to the config map for a all operations and sets the index to
 * that server.
 * @param url A string that contains the URL of the server
 * @param description A String that describes the server
 * @param variables A map between a variable name and its value. The value is used for substitution
 * in the server's URL template.
 */
void OAIUserServiceApi::setNewServerForAllOperations(
    const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables)
{
	for (auto keyIt = _serverIndices.keyBegin(); keyIt != _serverIndices.keyEnd(); keyIt++) {
		setServerIndex(*keyIt, addServerConfiguration(*keyIt, url, description, variables));
	}
}

/**
 * Appends a new ServerConfiguration to the config map for an operations and sets the index to that
 * server.
 * @param URL A string that contains the URL of the server
 * @param description A String that describes the server
 * @param variables A map between a variable name and its value. The value is used for substitution
 * in the server's URL template.
 */
void OAIUserServiceApi::setNewServer(
    const QString &operation,
    const QUrl &url,
    const QString &description,
    const QMap<QString, OAIServerVariable> &variables)
{
	setServerIndex(operation, addServerConfiguration(operation, url, description, variables));
}

void OAIUserServiceApi::addHeaders(const QString &key, const QString &value)
{
	_defaultHeaders.insert(key, value);
}

void OAIUserServiceApi::enableRequestCompression()
{
	_isRequestCompressionEnabled = true;
}

void OAIUserServiceApi::enableResponseCompression()
{
	_isResponseCompressionEnabled = true;
}

void OAIUserServiceApi::abortRequests()
{
	Q_EMIT abortRequestsSignal();
}

QString OAIUserServiceApi::getParamStylePrefix(const QString &style)
{
	if (style == "matrix") {
		return ";";
	} else if (style == "label") {
		return ".";
	} else if (style == "form") {
		return "&";
	} else if (style == "simple") {
		return "";
	} else if (style == "spaceDelimited") {
		return "&";
	} else if (style == "pipeDelimited") {
		return "&";
	} else {
		return "none";
	}
}

QString OAIUserServiceApi::getParamStyleSuffix(const QString &style)
{
	if (style == "matrix") {
		return "=";
	} else if (style == "label") {
		return "";
	} else if (style == "form") {
		return "=";
	} else if (style == "simple") {
		return "";
	} else if (style == "spaceDelimited") {
		return "=";
	} else if (style == "pipeDelimited") {
		return "=";
	} else {
		return "none";
	}
}

QString OAIUserServiceApi::getParamStyleDelimiter(
    const QString &style, const QString &name, bool isExplode)
{
	if (style == "matrix") {
		return (isExplode) ? ";" + name + "=" : ",";

	} else if (style == "label") {
		return (isExplode) ? "." : ",";

	} else if (style == "form") {
		return (isExplode) ? "&" + name + "=" : ",";

	} else if (style == "simple") {
		return ",";
	} else if (style == "spaceDelimited") {
		return (isExplode) ? "&" + name + "=" : " ";

	} else if (style == "pipeDelimited") {
		return (isExplode) ? "&" + name + "=" : "|";

	} else if (style == "deepObject") {
		return (isExplode) ? "&" : "none";

	} else {
		return "none";
	}
}

void OAIUserServiceApi::userServiceCreateUser(const OAIUser_serviceCreateUserRequest &body)
{
	QString fullPath = QString(
	    _serverConfigs["userServiceCreateUser"][_serverIndices.value("userServiceCreateUser")].URL()
	    + "/v1/users");

	OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
	worker->setTimeOut(_timeOut);
	worker->setWorkingDirectory(_workingDirectory);
	OAIHttpRequestInput input(fullPath, "POST");

	{
		QByteArray output = body.asJson().toUtf8();
		input.request_body.append(output);
	}
	for (auto keyValueIt = _defaultHeaders.keyValueBegin();
	     keyValueIt != _defaultHeaders.keyValueEnd();
	     keyValueIt++) {
		input.headers.insert(keyValueIt->first, keyValueIt->second);
	}

	connect(
	    worker,
	    &OAIHttpRequestWorker::on_execution_finished,
	    this,
	    &OAIUserServiceApi::userServiceCreateUserCallback);
	connect(this, &OAIUserServiceApi::abortRequestsSignal, worker, &QObject::deleteLater);
	connect(worker, &QObject::destroyed, this, [this]() {
		if (findChildren<OAIHttpRequestWorker *>().count() == 0) {
			Q_EMIT allPendingRequestsCompleted();
		}
	});

	worker->execute(&input);
}

void OAIUserServiceApi::userServiceCreateUserCallback(OAIHttpRequestWorker *worker)
{
	QString error_str = worker->error_str;
	QNetworkReply::NetworkError error_type = worker->error_type;

	if (worker->error_type != QNetworkReply::NoError) {
		error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
	}
	OAIUser_serviceCreateUserResponse output(QString(worker->response));
	worker->deleteLater();

	if (worker->error_type == QNetworkReply::NoError) {
		Q_EMIT userServiceCreateUserSignal(output);
		Q_EMIT userServiceCreateUserSignalFull(worker, output);
	} else {
#if defined(_MSC_VER)
// For MSVC
#	pragma warning(push)
#	pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#	pragma clang diagnostic push
#	pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#	pragma GCC diagnostic push
#	pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

		Q_EMIT userServiceCreateUserSignalE(output, error_type, error_str);
		Q_EMIT userServiceCreateUserSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#	pragma warning(pop)
#elif defined(__clang__)
#	pragma clang diagnostic pop
#elif defined(__GNUC__)
#	pragma GCC diagnostic pop
#endif

		Q_EMIT userServiceCreateUserSignalError(output, error_type, error_str);
		Q_EMIT userServiceCreateUserSignalErrorFull(worker, error_type, error_str);
	}
}

void OAIUserServiceApi::userServiceGetSettings(const QString &user_id)
{
	QString fullPath = QString(
	    _serverConfigs["userServiceGetSettings"][_serverIndices.value("userServiceGetSettings")].URL()
	    + "/v1/users/{userId}/settings");

	{
		QString user_idPathParam("{");
		user_idPathParam.append("userId").append("}");
		QString pathPrefix, pathSuffix, pathDelimiter;
		QString pathStyle = "";
		if (pathStyle == "") {
			pathStyle = "simple";
		}
		pathPrefix = getParamStylePrefix(pathStyle);
		pathSuffix = getParamStyleSuffix(pathStyle);
		pathDelimiter = getParamStyleDelimiter(pathStyle, "userId", false);
		QString paramString =
		    (pathStyle == "matrix") ? pathPrefix + "userId" + pathSuffix : pathPrefix;
		fullPath.replace(
		    user_idPathParam,
		    paramString + QUrl::toPercentEncoding(::OpenAPI::toStringValue(user_id)));
	}
	OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
	worker->setTimeOut(_timeOut);
	worker->setWorkingDirectory(_workingDirectory);
	OAIHttpRequestInput input(fullPath, "GET");

	for (auto keyValueIt = _defaultHeaders.keyValueBegin();
	     keyValueIt != _defaultHeaders.keyValueEnd();
	     keyValueIt++) {
		input.headers.insert(keyValueIt->first, keyValueIt->second);
	}

	connect(
	    worker,
	    &OAIHttpRequestWorker::on_execution_finished,
	    this,
	    &OAIUserServiceApi::userServiceGetSettingsCallback);
	connect(this, &OAIUserServiceApi::abortRequestsSignal, worker, &QObject::deleteLater);
	connect(worker, &QObject::destroyed, this, [this]() {
		if (findChildren<OAIHttpRequestWorker *>().count() == 0) {
			Q_EMIT allPendingRequestsCompleted();
		}
	});

	worker->execute(&input);
}

void OAIUserServiceApi::userServiceGetSettingsCallback(OAIHttpRequestWorker *worker)
{
	QString error_str = worker->error_str;
	QNetworkReply::NetworkError error_type = worker->error_type;

	if (worker->error_type != QNetworkReply::NoError) {
		error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
	}
	OAIUser_serviceGetSettingsResponse output(QString(worker->response));
	worker->deleteLater();

	if (worker->error_type == QNetworkReply::NoError) {
		Q_EMIT userServiceGetSettingsSignal(output);
		Q_EMIT userServiceGetSettingsSignalFull(worker, output);
	} else {
#if defined(_MSC_VER)
// For MSVC
#	pragma warning(push)
#	pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#	pragma clang diagnostic push
#	pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#	pragma GCC diagnostic push
#	pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

		Q_EMIT userServiceGetSettingsSignalE(output, error_type, error_str);
		Q_EMIT userServiceGetSettingsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#	pragma warning(pop)
#elif defined(__clang__)
#	pragma clang diagnostic pop
#elif defined(__GNUC__)
#	pragma GCC diagnostic pop
#endif

		Q_EMIT userServiceGetSettingsSignalError(output, error_type, error_str);
		Q_EMIT userServiceGetSettingsSignalErrorFull(worker, error_type, error_str);
	}
}

void OAIUserServiceApi::userServiceGetUser(const QString &user_id)
{
	QString fullPath = QString(
	    _serverConfigs["userServiceGetUser"][_serverIndices.value("userServiceGetUser")].URL()
	    + "/v1/users/{userId}");

	{
		QString user_idPathParam("{");
		user_idPathParam.append("userId").append("}");
		QString pathPrefix, pathSuffix, pathDelimiter;
		QString pathStyle = "";
		if (pathStyle == "") {
			pathStyle = "simple";
		}
		pathPrefix = getParamStylePrefix(pathStyle);
		pathSuffix = getParamStyleSuffix(pathStyle);
		pathDelimiter = getParamStyleDelimiter(pathStyle, "userId", false);
		QString paramString =
		    (pathStyle == "matrix") ? pathPrefix + "userId" + pathSuffix : pathPrefix;
		fullPath.replace(
		    user_idPathParam,
		    paramString + QUrl::toPercentEncoding(::OpenAPI::toStringValue(user_id)));
	}
	OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
	worker->setTimeOut(_timeOut);
	worker->setWorkingDirectory(_workingDirectory);
	OAIHttpRequestInput input(fullPath, "GET");

	for (auto keyValueIt = _defaultHeaders.keyValueBegin();
	     keyValueIt != _defaultHeaders.keyValueEnd();
	     keyValueIt++) {
		input.headers.insert(keyValueIt->first, keyValueIt->second);
	}

	connect(
	    worker,
	    &OAIHttpRequestWorker::on_execution_finished,
	    this,
	    &OAIUserServiceApi::userServiceGetUserCallback);
	connect(this, &OAIUserServiceApi::abortRequestsSignal, worker, &QObject::deleteLater);
	connect(worker, &QObject::destroyed, this, [this]() {
		if (findChildren<OAIHttpRequestWorker *>().count() == 0) {
			Q_EMIT allPendingRequestsCompleted();
		}
	});

	worker->execute(&input);
}

void OAIUserServiceApi::userServiceGetUserCallback(OAIHttpRequestWorker *worker)
{
	QString error_str = worker->error_str;
	QNetworkReply::NetworkError error_type = worker->error_type;

	if (worker->error_type != QNetworkReply::NoError) {
		error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
	}
	OAIUser_serviceGetUserResponse output(QString(worker->response));
	worker->deleteLater();

	if (worker->error_type == QNetworkReply::NoError) {
		Q_EMIT userServiceGetUserSignal(output);
		Q_EMIT userServiceGetUserSignalFull(worker, output);
	} else {
#if defined(_MSC_VER)
// For MSVC
#	pragma warning(push)
#	pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#	pragma clang diagnostic push
#	pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#	pragma GCC diagnostic push
#	pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

		Q_EMIT userServiceGetUserSignalE(output, error_type, error_str);
		Q_EMIT userServiceGetUserSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#	pragma warning(pop)
#elif defined(__clang__)
#	pragma clang diagnostic pop
#elif defined(__GNUC__)
#	pragma GCC diagnostic pop
#endif

		Q_EMIT userServiceGetUserSignalError(output, error_type, error_str);
		Q_EMIT userServiceGetUserSignalErrorFull(worker, error_type, error_str);
	}
}

void OAIUserServiceApi::userServiceUpdateSettings(
    const QString &user_id, const OAIUserServiceUpdateSettingsBody &body)
{
	QString fullPath = QString(
	    _serverConfigs["userServiceUpdateSettings"]
	                  [_serverIndices.value("userServiceUpdateSettings")]
	                      .URL()
	    + "/v1/users/{userId}/settings");

	{
		QString user_idPathParam("{");
		user_idPathParam.append("userId").append("}");
		QString pathPrefix, pathSuffix, pathDelimiter;
		QString pathStyle = "";
		if (pathStyle == "") {
			pathStyle = "simple";
		}
		pathPrefix = getParamStylePrefix(pathStyle);
		pathSuffix = getParamStyleSuffix(pathStyle);
		pathDelimiter = getParamStyleDelimiter(pathStyle, "userId", false);
		QString paramString =
		    (pathStyle == "matrix") ? pathPrefix + "userId" + pathSuffix : pathPrefix;
		fullPath.replace(
		    user_idPathParam,
		    paramString + QUrl::toPercentEncoding(::OpenAPI::toStringValue(user_id)));
	}
	OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
	worker->setTimeOut(_timeOut);
	worker->setWorkingDirectory(_workingDirectory);
	OAIHttpRequestInput input(fullPath, "PUT");

	{
		QByteArray output = body.asJson().toUtf8();
		input.request_body.append(output);
	}
	for (auto keyValueIt = _defaultHeaders.keyValueBegin();
	     keyValueIt != _defaultHeaders.keyValueEnd();
	     keyValueIt++) {
		input.headers.insert(keyValueIt->first, keyValueIt->second);
	}

	connect(
	    worker,
	    &OAIHttpRequestWorker::on_execution_finished,
	    this,
	    &OAIUserServiceApi::userServiceUpdateSettingsCallback);
	connect(this, &OAIUserServiceApi::abortRequestsSignal, worker, &QObject::deleteLater);
	connect(worker, &QObject::destroyed, this, [this]() {
		if (findChildren<OAIHttpRequestWorker *>().count() == 0) {
			Q_EMIT allPendingRequestsCompleted();
		}
	});

	worker->execute(&input);
}

void OAIUserServiceApi::userServiceUpdateSettingsCallback(OAIHttpRequestWorker *worker)
{
	QString error_str = worker->error_str;
	QNetworkReply::NetworkError error_type = worker->error_type;

	if (worker->error_type != QNetworkReply::NoError) {
		error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
	}
	OAIUser_serviceUpdateSettingsResponse output(QString(worker->response));
	worker->deleteLater();

	if (worker->error_type == QNetworkReply::NoError) {
		Q_EMIT userServiceUpdateSettingsSignal(output);
		Q_EMIT userServiceUpdateSettingsSignalFull(worker, output);
	} else {
#if defined(_MSC_VER)
// For MSVC
#	pragma warning(push)
#	pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#	pragma clang diagnostic push
#	pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#	pragma GCC diagnostic push
#	pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

		Q_EMIT userServiceUpdateSettingsSignalE(output, error_type, error_str);
		Q_EMIT userServiceUpdateSettingsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#	pragma warning(pop)
#elif defined(__clang__)
#	pragma clang diagnostic pop
#elif defined(__GNUC__)
#	pragma GCC diagnostic pop
#endif

		Q_EMIT userServiceUpdateSettingsSignalError(output, error_type, error_str);
		Q_EMIT userServiceUpdateSettingsSignalErrorFull(worker, error_type, error_str);
	}
}

void OAIUserServiceApi::userServiceUpdateUser(
    const QString &user_id, const OAIUserServiceUpdateUserBody &body)
{
	QString fullPath = QString(
	    _serverConfigs["userServiceUpdateUser"][_serverIndices.value("userServiceUpdateUser")].URL()
	    + "/v1/users/{userId}");

	{
		QString user_idPathParam("{");
		user_idPathParam.append("userId").append("}");
		QString pathPrefix, pathSuffix, pathDelimiter;
		QString pathStyle = "";
		if (pathStyle == "") {
			pathStyle = "simple";
		}
		pathPrefix = getParamStylePrefix(pathStyle);
		pathSuffix = getParamStyleSuffix(pathStyle);
		pathDelimiter = getParamStyleDelimiter(pathStyle, "userId", false);
		QString paramString =
		    (pathStyle == "matrix") ? pathPrefix + "userId" + pathSuffix : pathPrefix;
		fullPath.replace(
		    user_idPathParam,
		    paramString + QUrl::toPercentEncoding(::OpenAPI::toStringValue(user_id)));
	}
	OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
	worker->setTimeOut(_timeOut);
	worker->setWorkingDirectory(_workingDirectory);
	OAIHttpRequestInput input(fullPath, "PATCH");

	{
		QByteArray output = body.asJson().toUtf8();
		input.request_body.append(output);
	}
	for (auto keyValueIt = _defaultHeaders.keyValueBegin();
	     keyValueIt != _defaultHeaders.keyValueEnd();
	     keyValueIt++) {
		input.headers.insert(keyValueIt->first, keyValueIt->second);
	}

	connect(
	    worker,
	    &OAIHttpRequestWorker::on_execution_finished,
	    this,
	    &OAIUserServiceApi::userServiceUpdateUserCallback);
	connect(this, &OAIUserServiceApi::abortRequestsSignal, worker, &QObject::deleteLater);
	connect(worker, &QObject::destroyed, this, [this]() {
		if (findChildren<OAIHttpRequestWorker *>().count() == 0) {
			Q_EMIT allPendingRequestsCompleted();
		}
	});

	worker->execute(&input);
}

void OAIUserServiceApi::userServiceUpdateUserCallback(OAIHttpRequestWorker *worker)
{
	QString error_str = worker->error_str;
	QNetworkReply::NetworkError error_type = worker->error_type;

	if (worker->error_type != QNetworkReply::NoError) {
		error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
	}
	OAIUser_serviceUpdateUserResponse output(QString(worker->response));
	worker->deleteLater();

	if (worker->error_type == QNetworkReply::NoError) {
		Q_EMIT userServiceUpdateUserSignal(output);
		Q_EMIT userServiceUpdateUserSignalFull(worker, output);
	} else {
#if defined(_MSC_VER)
// For MSVC
#	pragma warning(push)
#	pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#	pragma clang diagnostic push
#	pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#	pragma GCC diagnostic push
#	pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

		Q_EMIT userServiceUpdateUserSignalE(output, error_type, error_str);
		Q_EMIT userServiceUpdateUserSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#	pragma warning(pop)
#elif defined(__clang__)
#	pragma clang diagnostic pop
#elif defined(__GNUC__)
#	pragma GCC diagnostic pop
#endif

		Q_EMIT userServiceUpdateUserSignalError(output, error_type, error_str);
		Q_EMIT userServiceUpdateUserSignalErrorFull(worker, error_type, error_str);
	}
}

void OAIUserServiceApi::tokenAvailable()
{
	oauthToken token;
	switch (_OauthMethod) {
	case 1: // implicit flow
		token = _implicitFlow.getToken(_latestScope.join(" "));
		if (token.isValid()) {
			_latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
			_latestWorker->execute(&_latestInput);
		} else {
			_implicitFlow.removeToken(_latestScope.join(" "));
			qDebug() << "Could not retrieve a valid token";
		}
		break;
	case 2: // authorization flow
		token = _authFlow.getToken(_latestScope.join(" "));
		if (token.isValid()) {
			_latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
			_latestWorker->execute(&_latestInput);
		} else {
			_authFlow.removeToken(_latestScope.join(" "));
			qDebug() << "Could not retrieve a valid token";
		}
		break;
	case 3: // client credentials flow
		token = _credentialFlow.getToken(_latestScope.join(" "));
		if (token.isValid()) {
			_latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
			_latestWorker->execute(&_latestInput);
		} else {
			_credentialFlow.removeToken(_latestScope.join(" "));
			qDebug() << "Could not retrieve a valid token";
		}
		break;
	case 4: // resource owner password flow
		token = _passwordFlow.getToken(_latestScope.join(" "));
		if (token.isValid()) {
			_latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
			_latestWorker->execute(&_latestInput);
		} else {
			_credentialFlow.removeToken(_latestScope.join(" "));
			qDebug() << "Could not retrieve a valid token";
		}
		break;
	default:
		qDebug() << "No Oauth method set!";
		break;
	}
}
} // namespace OpenAPI
